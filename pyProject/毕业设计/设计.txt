tdvrptw

总体思路:
初始化,使用logistics混沌算子
先使用pso生成解,然后使用kopt算法等改进当前算法

论文(水法)：
背景
算法介绍
数学模型
代码
仿真
消融实验
分析
结束

条件：
n车
m客户
车容量c
客户需求r
客户服务时间s
客户时间窗th1，ts1，ts2，th2(th是硬时间窗，ts是软时间窗)
地图(路线权重)
时变车速(统计多个城市，分类，分别取平均值)

变量设置：
y(i，k)=1 客户i的任务由k车完成
x(i，j，k)=1 k车从i到k
t(i，k) k车到i的时间  


约束:
车辆不超载：∑y(i，k)*Ri<=c  (i=1...m)(k=1...n)
每个客户都被服务：∑y(i，k)=m  (k=1...k)(i=1...m)
每个客户仅被服务一次：∑y(i，k)=1 (i=1...m)(k=1...n)
车辆不重复服务一个站点：∑x(i，j，k)=1 (i=1...m，除了j)(j=1...m，k=1...n)
使用的车辆少于现有：∑x(0，i，k)<=n  (i=1...m，k=1...n)
时间窗：th1(i)<=t(i，k)<=th2(i)



成本计算：
油耗：里程，荷载，自重，速度，启动制动，折旧
人工：驾驶员工资

满意度计算：
在软时间窗之内，满意度不减少
在软时间窗之外，硬时间窗之内，满意度减少=到达最近软时间窗边界的值




数据集的数据单元命名：
数据集名称：caseName
车辆数量：vehicleNum
车辆容量：vehicleCapacity
客户集合：customers
客户编号：cusNo
客户坐标：x,y
客户需求：demand
客户硬时间窗：readyTime，dueDate
客户软时间窗：wantTime1，wantTime2
客户服务时间：serviceTime





粒子：
位置向量
速度向量
分数：成本，满意度
个人最佳：list，需要包含pos向量和分数信息
支配关系函数
混沌映射算法：初始化
kopt算法: https://blog.csdn.net/sinat_41348401/article/details/126920506
莱维飞行：更新的算法
计算分数算法：



PSO：
粒子群
群体最佳：list，需要包含pos向量和分数信息
道路信息：实时路况，拥堵信息
客户信息：客户点分布，需求等


util：
轮盘赌算法：用于选择best集合中数据
*copy函数：复制一个obj，但是排除特定的属性
*支配排序函数：
*爬取高德信息函数：
解析高德信息函数：放到mysql，然后写去除脏数据和获取拥堵关系
数据解析函数：解析homberger和solomon数据集
画图函数：每一代的分布，帕累托前沿


















2-opt:
input=0->path->0,以及对应的位置速度
path=v1->v2->...->vn
假设斩断
va->va+1和vb->vb+1(a<b)
然后重新连接
得到
v1->...va->vb->vb-1->...va+1->vb+1->...vn
(注意,i+1->j的路径反向了)
如果路径变短，则交换，否则不交换
注意,需要记录同一个联通分量的切割点,否则可能造成回路
且需要同步更新位置速度参数,否则会造成学习效果差